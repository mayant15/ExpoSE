domain JSValue {
    function Null(): JSValue
    function Undefined(): JSValue
    function Number(i: Int): JSValue
    function Boolean(b: Bool): JSValue
    function TypeError(): JSValue

    axiom {forall i: Int, j: Int :: {Number(i), Number(j)} Number(i) == Number(j) ==> i == j}
    axiom {forall i: Bool, j: Bool :: {Boolean(i), Boolean(j)} Boolean(i) == Boolean(j) ==> i == j}

    // ------------------------------------------------------------------------
    
    function type(val: JSValue): Int

    axiom { forall x: JSValue :: {type(x)} type(x) >= 0 && type(x) <= 4 }

    axiom { type(Null()) == 0 }
    axiom { forall x: JSValue :: {type(x)} type(x) == 0 ==> x == Null() }
    axiom { type(Undefined()) == 1 }
    axiom { forall x: JSValue :: {type(x)} type(x) == 1 ==> x == Undefined() }
    axiom { forall i: Int :: type(Number(i)) == 2 }
    axiom { forall x: JSValue :: {type(x)} type(x) == 2 ==> exists i: Int :: x == Number(i) }
    axiom { forall b: Bool :: type(Boolean(b)) == 3 }
    axiom { forall x: JSValue :: {type(x)} type(x) == 3 ==> exists b: Bool :: x == Boolean(b) }
    axiom { forall a: JSValue, b : JSValue :: a == b ==> type(a) == type(b) }
    axiom { type(TypeError()) == 4 }
    axiom { forall x: JSValue :: {type(x)} type(x) == 4 ==> x == TypeError() }

    // ------------------------------------------------------------------------
    // Utility functions to extract data out of a JSValue. Type mismatches are
    // not defined (TODO)

    function toNumber(val: JSValue): Int
    axiom { forall i: Int :: {toNumber(Number(i))} toNumber(Number(i)) == i }

    function toBoolean(val: JSValue): Bool
    axiom { forall b: Bool :: {toBoolean(Boolean(b))} toBoolean(Boolean(b)) == b }

    // ------------------------------------------------------------------------

    function addition(x: JSValue, y: JSValue): JSValue
    axiom { forall x: Int, y: Int :: {addition(Number(x), Number(y))} addition(Number(x), Number(y)) == Number(x + y) }
    axiom { forall x: JSValue, y: JSValue :: {addition(x, y)} (type(x) != 2 || type(y) != 2) ==> addition(x, y) == TypeError() }

    // ------------------------------------------------------------------------
    // https://262.ecma-international.org/#sec-isstrictlyequal

    function isStrictlyEqual(a: JSValue, b: JSValue): Bool

    axiom { forall a: JSValue, b: JSValue :: {isStrictlyEqual(a, b)} type(a) != type(b) ==> isStrictlyEqual(a, b) == false }
    axiom { forall i: Int, j: Int :: isStrictlyEqual(Number(i), Number(j)) == (i == j) }
    axiom { forall a: Bool, b: Bool :: isStrictlyEqual(Boolean(a), Boolean(b)) == (a == b) }
    axiom { isStrictlyEqual(Null(), Null()) == true }
    axiom { isStrictlyEqual(Undefined(), Undefined()) == true }

    // ------------------------------------------------------------------------
    // https://262.ecma-international.org/#sec-islooselyequal
    // TODO: https://262.ecma-international.org/#sec-IsHTMLDDA-internal-slot-aec

    // function isLooselyEqual(a: JSValue, b: JSValue): Bool

    // axiom { forall a: JSValue, b: JSValue :: {isLooselyEqual(a, b)} type(a) == type(b) ==> isLooselyEqual(a, b) == isStrictlyEqual(a, b) }
    // axiom { isLooselyEqual(Null(), Undefined()) == true }
    // axiom { isLooselyEqual(Undefined(), Null()) == true }
    // axiom { forall a: Bool, b: JSValue :: {isLooselyEqual(Boolean(a), b)} isLooselyEqual(Boolean(a), b) == isLooselyEqual(Number(a ? 1 : 0), b) }
    // axiom { forall a: JSValue, b: Bool :: {isLooselyEqual(a, Boolean(b))} isLooselyEqual(a, Boolean(b)) == isLooselyEqual(a, Number(b ? 1 : 0)) }
    
    // ------------------------------------------------------------------------
}

// method test_addition(x: JSValue) {
//     assert isStrictlyEqual(addition(x, Number(3)), Number(45)) ==> x == Number(42)
//     // assert isStrictlyEqual(addition(x, Number(3)), Number(45))
// }

method test_strict_equals(x: JSValue) {
    assert !isStrictlyEqual(x, Null())
    // assert x == Null()
    // assert isStrictlyEqual(x, Null()) ==> x == Null()
    // assert isStrictlyEqual(Undefined(), x) ==> x == Undefined()
}

// method test_strict_equals_null(x: JSValue) {
//     assert isStrictlyEqual(x, Null()) ==> x == Null()
// }

// method test_strict_equals(x: JSValue) {
//     assert isStrictlyEqual(Number(1), Number(1))
//     assert isStrictlyEqual(Boolean(true), Boolean(true))
//     assert !isStrictlyEqual(Boolean(false), Boolean(true))
//     assert !isStrictlyEqual(Boolean(true), Boolean(false))
//     assert isStrictlyEqual(Boolean(false), Boolean(false))
//     assert !isStrictlyEqual(Boolean(true), Number(1))

//     //  TODO: (MM) NaN, +Infinity, -Infinity, MAX_VALUE, MIN_VALUE, +0, -0
// }

// method test() {
//     assert !false
// }

// method testStrictEquals(x: JSValue) {
//     assert forall y: JSValue :: isStrictlyEqual(y, Null()) ==> y == Null()
//     // assert !isStrictlyEqual(x, Null())
// }

// method test() {
//     assert isStrictlyEqual(Null(), Null())
//     assert isStrictlyEqual(Undefined(), Undefined())

//     assert !isStrictlyEqual(Number(0), Number(1))
//     assert isStrictlyEqual(Number(0), Number(0))

//     assert !isStrictlyEqual(Number(0), Boolean(true))
//     assert !isStrictlyEqual(Boolean(false), Boolean(true))
//     assert isStrictlyEqual(Boolean(false), Boolean(false))
// }

// method testIsLooselyEqual() {
//     assert isLooselyEqual(Null(), Null())
//     assert isLooselyEqual(Null(), Undefined())
//     assert isLooselyEqual(Undefined(), Null())
//     assert isLooselyEqual(Undefined(), Undefined())

//     assert !isLooselyEqual(Number(42), Boolean(true))
//     assert !isLooselyEqual(Number(42), Boolean(false))
//     assert isLooselyEqual(Number(1), Boolean(true))
//     assert !isLooselyEqual(Number(1), Boolean(false))
//     assert !isLooselyEqual(Number(0), Boolean(true))
//     assert isLooselyEqual(Number(0), Boolean(false))
// }
