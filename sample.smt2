(set-option :global-decls true) ; Necessary for push pop mode
(set-option :auto_config false)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :type_check true)
(set-option :smt.mbqi false)
(set-option :pp.bv_literals false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.arith.solver 2)
(set-option :model.v2 true)
(set-option :smt.qi.max_multi_patterns 1000)
(set-option :timeout 100)


(declare-sort JSValue 0)
(declare-fun Number<JSValue> (Int) JSValue)
(declare-fun inj!2 (JSValue) Int)
(declare-fun Boolean<JSValue> (Bool) JSValue)
(declare-fun inj!3 (JSValue) Bool)
(declare-fun type<Int> (JSValue) Int)
(declare-fun Null<JSValue> () JSValue)
(declare-fun Undefined<JSValue> () JSValue)
(declare-fun i!0 (JSValue) Int)
(declare-fun b!1 (JSValue) Bool)
(declare-fun TypeError<JSValue> () JSValue)
(declare-fun toNumber<Int> (JSValue) Int)
(declare-fun toBoolean<Bool> (JSValue) Bool)
(declare-fun addition<JSValue> (JSValue JSValue) JSValue)
(declare-fun isStrictlyEqual<Bool> (JSValue JSValue) Bool)
(declare-fun X () JSValue)
(define-funs-rec ( ( str.repeat ((x!1 String) (x!2 Int)) String)
                   ( str.whiteLeft ((x!1 String) (x!2 Int)) Int)
                   ( str.whiteRight ((x!1 String) (x!2 Int)) Int))
                 ( (ite (<= x!2 0)
                        ""
                        (str.++ x!1 ((_ str.repeat 0) x!1 (- x!2 1))))
                   (ite (= (str.at x!1 x!2) " ")
                        ((_ str.whiteLeft 0) x!1 (+ x!2 1))
                        x!2)
                   (ite (= (str.at x!1 x!2) " ")
                        ((_ str.whiteRight 0) x!1 (- x!2 1))
                        x!2)))
(assert (forall ((x!1 Int))
  (! (= (inj!2 (Number<JSValue> x!1)) x!1)
     :pattern ((Number<JSValue> x!1))
     :weight 0)))
(assert (forall ((x!1 Bool))
  (! (= (inj!3 (Boolean<JSValue> x!1)) x!1)
     :pattern ((Boolean<JSValue> x!1))
     :weight 0)))
(assert (forall ((x JSValue))
  (! (let ((a!1 (or (not (>= (type<Int> x) 0)) (not (<= (type<Int> x) 4)))))
       (not a!1))
     :pattern ((type<Int> x)))))
(assert (= (type<Int> Null<JSValue>) 0))
(assert (forall ((x JSValue))
  (! (or (not (= (type<Int> x) 0)) (= x Null<JSValue>))
     :pattern ((type<Int> x)))))
(assert (= (type<Int> Undefined<JSValue>) 1))
(assert (forall ((x JSValue))
  (! (or (not (= (type<Int> x) 1)) (= x Undefined<JSValue>))
     :pattern ((type<Int> x)))))
(assert (forall ((i Int))
  (! (= (type<Int> (Number<JSValue> i)) 2)
     :pattern ((type<Int> (Number<JSValue> i))))))
(assert (forall ((x JSValue))
  (! (or (not (= (type<Int> x) 2)) (= x (Number<JSValue> (i!0 x))))
     :pattern ((type<Int> x)))))
(assert (forall ((b Bool))
  (! (= (type<Int> (Boolean<JSValue> b)) 3)
     :pattern ((type<Int> (Boolean<JSValue> b))))))
(assert (forall ((x JSValue))
  (! (or (not (= (type<Int> x) 3)) (= x (Boolean<JSValue> (b!1 x))))
     :pattern ((type<Int> x)))))
(assert (forall ((a JSValue) (b JSValue))
  (! (or (not (= a b)) (= (type<Int> a) (type<Int> b)))
     :pattern ((type<Int> a) (type<Int> b)))))
(assert (= (type<Int> TypeError<JSValue>) 4))
(assert (forall ((x JSValue))
  (! (or (not (= (type<Int> x) 4)) (= x TypeError<JSValue>))
     :pattern ((type<Int> x)))))
(assert (forall ((i Int))
  (! (= (toNumber<Int> (Number<JSValue> i)) i)
     :pattern ((toNumber<Int> (Number<JSValue> i))))))
(assert (forall ((b Bool))
  (! (= (toBoolean<Bool> (Boolean<JSValue> b)) b)
     :pattern ((toBoolean<Bool> (Boolean<JSValue> b))))))
(assert (forall ((x Int) (y Int))
  (! (= (addition<JSValue> (Number<JSValue> x) (Number<JSValue> y))
        (Number<JSValue> (+ y x)))
     :pattern ((addition<JSValue> (Number<JSValue> x) (Number<JSValue> y))))))
(assert (forall ((x JSValue) (y JSValue))
  (! (let ((a!1 (or (not (= (type<Int> x) 2)) (not (= (type<Int> y) 2)))))
       (or (not a!1) (= (addition<JSValue> x y) TypeError<JSValue>)))
     :pattern ((addition<JSValue> x y)))))
(assert (forall ((a JSValue) (b JSValue))
  (! (or (= (type<Int> a) (type<Int> b)) (not (isStrictlyEqual<Bool> a b)))
     :pattern ((isStrictlyEqual<Bool> a b)))))
(assert (forall ((i Int) (j Int))
  (! (= (isStrictlyEqual<Bool> (Number<JSValue> i) (Number<JSValue> j)) (= i j))
     :pattern ((isStrictlyEqual<Bool> (Number<JSValue> i) (Number<JSValue> j))))))
(assert (forall ((a Bool) (b Bool))
  (! (= (isStrictlyEqual<Bool> (Boolean<JSValue> a) (Boolean<JSValue> b))
        (= a b))
     :pattern ((isStrictlyEqual<Bool> (Boolean<JSValue> a) (Boolean<JSValue> b))))))
(assert (isStrictlyEqual<Bool> Null<JSValue> Null<JSValue>))
(assert (isStrictlyEqual<Bool> Undefined<JSValue> Undefined<JSValue>))

(push)

(assert (isStrictlyEqual<Bool> X Null<JSValue>))

(check-sat)
(get-info :reason-unknown)
(get-model)

(pop)
